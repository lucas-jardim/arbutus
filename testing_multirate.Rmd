---
title: "Testing Multirate BM"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(geiger)
library(OUwie)
library(tidyverse)
```

## First, simulate tree

``` {r treesim}
#tree <- stree(128, type = "balanced", tip.label = as.character(c(1:128))) %>% compute.brlen()
tree <- sim.bdtree(n = 128, seed = 69)
plot(tree)
```

## Second, simulate BM character data with 2 different rates

``` {r datasim}
#Make nodes correspond to selective regimes
tree2 <- sim.bdtree(n = 10)
tree2$node.label <- c(rep.int(1, 5), rep.int(2, (10-6)))
plot.phylo(tree2, show.node.label = TRUE)

tree$node.label <- c(rep.int(1, 64), rep.int(2, (128-65)))
plot.phylo(tree, show.node.label = TRUE)

#Make dataframe
df_species <- tree$tip.label
df_regime <- c(rep.int(1, 64), rep.int(2, (128-64)))
df <- data.frame(df_species, df_regime) %>% rename(Genus_species = df_species, Reg = df_regime)

#Now sim
sim_dat <- OUwie.sim(phy = tree, data = df, alpha = c(1e-10,1e-10), sigma.sq = c(0.45,0.90), theta0 = 1.0, theta = c(0,0))

#Fit the data
sim_fit <- OUwie(phy = tree, data = sim_dat, model = "BMS")
```

Next, we create the following functions:
  1. model_info
  2. parnames
  3. make_model_phylo
  
``` {r model_info}

model_type.OUwie <- function(fit, ...){
  ret <- fit$model
  if (is.null(ret) || !is.character(ret) || length(ret) != 1)
    stop("Failed to extract model type from OUwie fit")
  ret
}

model_data.OUwie <- function(fit, ...) {
 list(phy=fit$phy, data=fit$data)
}

model_pars.OUwie <- function(fit, ...) {
  list(sigsq1 = fit$solution[2], sigsq2 = fit$solution[4], SE = fit$solution.se)
}

#' @method model_info gfit
#' @export
model_info.OUwie <- function(fit, ...) {
  m <- list(data=model_data(fit),
            pars=model_pars(fit),
            type=model_type(fit))
  class(m) <- "fitOU"
  m
}
```

``` {r parnames}
#To add to internal.R script
parnames.bms <- function()
  c("sigsq1", "sigsq2", "SE")
```

``` {r model_phylo}
make_model_phylo.fitOU <- function(x, ...){
  ## get model
    model <- x$type

    ## get tree
    phy <- x$data$phy

    ## get parameters
    pars <- x$pars

    ## Translation function; all have argument list (phy, pars)
    tr <- switch(model,
                 BMS=model_phylo_bms)

    if (is.data.frame(pars)) {
      rphy <- lapply(seq_len(nrow(pars)), function(i)
                     tr(phy, pars[i,]))
      class(rphy) <- "multiPhylo"
    } else {
      rphy <- tr(phy, pars)
    }

    ## return rescaled phylogeny
    rphy
}

model_phylo_bms <- function(phy, pars){
    if (pars$sigsq1 < 0 || pars$sigsq2 < 0)
        stop("Parameters need to be non-negative")
    #The first 2n edges are sigsq1 (n = number of regime 1), rest are sigsq2
    n = sum(phy$node.label == 1)
    phy$edge.length[1:(2*n)] <- phy$edge.length[1:(2*n)] * pars$sigsq1
    phy$edge.length[(2*n+1):length(phy$edge.length)] <- phy$edge.length[(2*n+1):length(phy$edge.length)] * pars$sigsq2
    #ifelse(!is.null(pars$SE), phy = model_phylo_ouse(phy, pars), phy = phy)
    phy    
}

model_phylo_ouse <- function(phy, pars) {
  if (pars$SE < 0)
    stop("SE must be non-negative")
  tips <- phy$edge[,2] <= Ntip(phy)
  phy$edge.length[tips] <- phy$edge.length[tips] + pars$SE^2
  phy
}
```

``` {r}
arbutus::arbutus(sim_fit)

```